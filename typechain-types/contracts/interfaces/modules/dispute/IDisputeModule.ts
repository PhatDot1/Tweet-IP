/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export interface IDisputeModuleInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "arbitrationPolicies"
      | "arbitrationRelayer"
      | "baseArbitrationPolicy"
      | "cancelDispute"
      | "disputeCounter"
      | "disputes"
      | "isIpTagged"
      | "isWhitelistedArbitrationPolicy"
      | "isWhitelistedDisputeTag"
      | "raiseDispute"
      | "resolveDispute"
      | "setArbitrationPolicy"
      | "setArbitrationPolicyCooldown"
      | "setArbitrationRelayer"
      | "setBaseArbitrationPolicy"
      | "setDisputeJudgement"
      | "tagIfRelatedIpInfringed"
      | "updateActiveArbitrationPolicy"
      | "whitelistArbitrationPolicy"
      | "whitelistDisputeTag"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ArbitrationPolicyCooldownUpdated"
      | "ArbitrationPolicySet"
      | "ArbitrationPolicyWhitelistUpdated"
      | "ArbitrationRelayerUpdated"
      | "DefaultArbitrationPolicyUpdated"
      | "DisputeCancelled"
      | "DisputeJudgementSet"
      | "DisputeRaised"
      | "DisputeResolved"
      | "IpTaggedOnRelatedIpInfringement"
      | "TagWhitelistUpdated"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "arbitrationPolicies",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "arbitrationRelayer",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "baseArbitrationPolicy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelDispute",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "disputeCounter",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "disputes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isIpTagged",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isWhitelistedArbitrationPolicy",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isWhitelistedDisputeTag",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "raiseDispute",
    values: [AddressLike, BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "resolveDispute",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setArbitrationPolicy",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setArbitrationPolicyCooldown",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setArbitrationRelayer",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setBaseArbitrationPolicy",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setDisputeJudgement",
    values: [BigNumberish, boolean, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tagIfRelatedIpInfringed",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateActiveArbitrationPolicy",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "whitelistArbitrationPolicy",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "whitelistDisputeTag",
    values: [BytesLike, boolean]
  ): string;

  decodeFunctionResult(
    functionFragment: "arbitrationPolicies",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "arbitrationRelayer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "baseArbitrationPolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelDispute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeCounter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "disputes", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isIpTagged", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isWhitelistedArbitrationPolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isWhitelistedDisputeTag",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "raiseDispute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resolveDispute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setArbitrationPolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setArbitrationPolicyCooldown",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setArbitrationRelayer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBaseArbitrationPolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDisputeJudgement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tagIfRelatedIpInfringed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateActiveArbitrationPolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "whitelistArbitrationPolicy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "whitelistDisputeTag",
    data: BytesLike
  ): Result;
}

export namespace ArbitrationPolicyCooldownUpdatedEvent {
  export type InputTuple = [cooldown: BigNumberish];
  export type OutputTuple = [cooldown: bigint];
  export interface OutputObject {
    cooldown: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ArbitrationPolicySetEvent {
  export type InputTuple = [
    ipId: AddressLike,
    arbitrationPolicy: AddressLike,
    nextArbitrationUpdateTimestamp: BigNumberish
  ];
  export type OutputTuple = [
    ipId: string,
    arbitrationPolicy: string,
    nextArbitrationUpdateTimestamp: bigint
  ];
  export interface OutputObject {
    ipId: string;
    arbitrationPolicy: string;
    nextArbitrationUpdateTimestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ArbitrationPolicyWhitelistUpdatedEvent {
  export type InputTuple = [arbitrationPolicy: AddressLike, allowed: boolean];
  export type OutputTuple = [arbitrationPolicy: string, allowed: boolean];
  export interface OutputObject {
    arbitrationPolicy: string;
    allowed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ArbitrationRelayerUpdatedEvent {
  export type InputTuple = [
    arbitrationPolicy: AddressLike,
    arbitrationRelayer: AddressLike
  ];
  export type OutputTuple = [
    arbitrationPolicy: string,
    arbitrationRelayer: string
  ];
  export interface OutputObject {
    arbitrationPolicy: string;
    arbitrationRelayer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DefaultArbitrationPolicyUpdatedEvent {
  export type InputTuple = [arbitrationPolicy: AddressLike];
  export type OutputTuple = [arbitrationPolicy: string];
  export interface OutputObject {
    arbitrationPolicy: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DisputeCancelledEvent {
  export type InputTuple = [disputeId: BigNumberish, data: BytesLike];
  export type OutputTuple = [disputeId: bigint, data: string];
  export interface OutputObject {
    disputeId: bigint;
    data: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DisputeJudgementSetEvent {
  export type InputTuple = [
    disputeId: BigNumberish,
    decision: boolean,
    data: BytesLike
  ];
  export type OutputTuple = [
    disputeId: bigint,
    decision: boolean,
    data: string
  ];
  export interface OutputObject {
    disputeId: bigint;
    decision: boolean;
    data: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DisputeRaisedEvent {
  export type InputTuple = [
    disputeId: BigNumberish,
    targetIpId: AddressLike,
    caller: AddressLike,
    disputeInitiator: AddressLike,
    disputeTimestamp: BigNumberish,
    arbitrationPolicy: AddressLike,
    disputeEvidenceHash: BytesLike,
    targetTag: BytesLike,
    data: BytesLike
  ];
  export type OutputTuple = [
    disputeId: bigint,
    targetIpId: string,
    caller: string,
    disputeInitiator: string,
    disputeTimestamp: bigint,
    arbitrationPolicy: string,
    disputeEvidenceHash: string,
    targetTag: string,
    data: string
  ];
  export interface OutputObject {
    disputeId: bigint;
    targetIpId: string;
    caller: string;
    disputeInitiator: string;
    disputeTimestamp: bigint;
    arbitrationPolicy: string;
    disputeEvidenceHash: string;
    targetTag: string;
    data: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace DisputeResolvedEvent {
  export type InputTuple = [disputeId: BigNumberish, data: BytesLike];
  export type OutputTuple = [disputeId: bigint, data: string];
  export interface OutputObject {
    disputeId: bigint;
    data: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace IpTaggedOnRelatedIpInfringementEvent {
  export type InputTuple = [
    disputeId: BigNumberish,
    infringingIpId: AddressLike,
    ipIdToTag: AddressLike,
    infringerDisputeId: BigNumberish,
    tag: BytesLike,
    disputeTimestamp: BigNumberish
  ];
  export type OutputTuple = [
    disputeId: bigint,
    infringingIpId: string,
    ipIdToTag: string,
    infringerDisputeId: bigint,
    tag: string,
    disputeTimestamp: bigint
  ];
  export interface OutputObject {
    disputeId: bigint;
    infringingIpId: string;
    ipIdToTag: string;
    infringerDisputeId: bigint;
    tag: string;
    disputeTimestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TagWhitelistUpdatedEvent {
  export type InputTuple = [tag: BytesLike, allowed: boolean];
  export type OutputTuple = [tag: string, allowed: boolean];
  export interface OutputObject {
    tag: string;
    allowed: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IDisputeModule extends BaseContract {
  connect(runner?: ContractRunner | null): IDisputeModule;
  waitForDeployment(): Promise<this>;

  interface: IDisputeModuleInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  arbitrationPolicies: TypedContractMethod<
    [ipId: AddressLike],
    [string],
    "view"
  >;

  arbitrationRelayer: TypedContractMethod<
    [arbitrationPolicy: AddressLike],
    [string],
    "view"
  >;

  baseArbitrationPolicy: TypedContractMethod<[], [string], "view">;

  cancelDispute: TypedContractMethod<
    [disputeId: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;

  disputeCounter: TypedContractMethod<[], [bigint], "view">;

  disputes: TypedContractMethod<
    [disputeId: BigNumberish],
    [
      [string, string, bigint, string, string, string, string, bigint] & {
        targetIpId: string;
        disputeInitiator: string;
        disputeTimestamp: bigint;
        arbitrationPolicy: string;
        disputeEvidenceHash: string;
        targetTag: string;
        currentTag: string;
        infringerDisputeId: bigint;
      }
    ],
    "view"
  >;

  isIpTagged: TypedContractMethod<[ipId: AddressLike], [boolean], "view">;

  isWhitelistedArbitrationPolicy: TypedContractMethod<
    [arbitrationPolicy: AddressLike],
    [boolean],
    "view"
  >;

  isWhitelistedDisputeTag: TypedContractMethod<
    [tag: BytesLike],
    [boolean],
    "view"
  >;

  raiseDispute: TypedContractMethod<
    [
      targetIpId: AddressLike,
      disputeEvidenceHash: BytesLike,
      targetTag: BytesLike,
      data: BytesLike
    ],
    [bigint],
    "nonpayable"
  >;

  resolveDispute: TypedContractMethod<
    [disputeId: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;

  setArbitrationPolicy: TypedContractMethod<
    [ipId: AddressLike, arbitrationPolicy: AddressLike],
    [void],
    "nonpayable"
  >;

  setArbitrationPolicyCooldown: TypedContractMethod<
    [cooldown: BigNumberish],
    [void],
    "nonpayable"
  >;

  setArbitrationRelayer: TypedContractMethod<
    [arbitrationPolicy: AddressLike, arbPolicyRelayer: AddressLike],
    [void],
    "nonpayable"
  >;

  setBaseArbitrationPolicy: TypedContractMethod<
    [arbitrationPolicy: AddressLike],
    [void],
    "nonpayable"
  >;

  setDisputeJudgement: TypedContractMethod<
    [disputeId: BigNumberish, decision: boolean, data: BytesLike],
    [void],
    "nonpayable"
  >;

  tagIfRelatedIpInfringed: TypedContractMethod<
    [ipIdToTag: AddressLike, infringerDisputeId: BigNumberish],
    [void],
    "nonpayable"
  >;

  updateActiveArbitrationPolicy: TypedContractMethod<
    [ipId: AddressLike],
    [string],
    "nonpayable"
  >;

  whitelistArbitrationPolicy: TypedContractMethod<
    [arbitrationPolicy: AddressLike, allowed: boolean],
    [void],
    "nonpayable"
  >;

  whitelistDisputeTag: TypedContractMethod<
    [tag: BytesLike, allowed: boolean],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "arbitrationPolicies"
  ): TypedContractMethod<[ipId: AddressLike], [string], "view">;
  getFunction(
    nameOrSignature: "arbitrationRelayer"
  ): TypedContractMethod<[arbitrationPolicy: AddressLike], [string], "view">;
  getFunction(
    nameOrSignature: "baseArbitrationPolicy"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "cancelDispute"
  ): TypedContractMethod<
    [disputeId: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "disputeCounter"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "disputes"
  ): TypedContractMethod<
    [disputeId: BigNumberish],
    [
      [string, string, bigint, string, string, string, string, bigint] & {
        targetIpId: string;
        disputeInitiator: string;
        disputeTimestamp: bigint;
        arbitrationPolicy: string;
        disputeEvidenceHash: string;
        targetTag: string;
        currentTag: string;
        infringerDisputeId: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "isIpTagged"
  ): TypedContractMethod<[ipId: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isWhitelistedArbitrationPolicy"
  ): TypedContractMethod<[arbitrationPolicy: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isWhitelistedDisputeTag"
  ): TypedContractMethod<[tag: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "raiseDispute"
  ): TypedContractMethod<
    [
      targetIpId: AddressLike,
      disputeEvidenceHash: BytesLike,
      targetTag: BytesLike,
      data: BytesLike
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "resolveDispute"
  ): TypedContractMethod<
    [disputeId: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setArbitrationPolicy"
  ): TypedContractMethod<
    [ipId: AddressLike, arbitrationPolicy: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setArbitrationPolicyCooldown"
  ): TypedContractMethod<[cooldown: BigNumberish], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "setArbitrationRelayer"
  ): TypedContractMethod<
    [arbitrationPolicy: AddressLike, arbPolicyRelayer: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setBaseArbitrationPolicy"
  ): TypedContractMethod<
    [arbitrationPolicy: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setDisputeJudgement"
  ): TypedContractMethod<
    [disputeId: BigNumberish, decision: boolean, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "tagIfRelatedIpInfringed"
  ): TypedContractMethod<
    [ipIdToTag: AddressLike, infringerDisputeId: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateActiveArbitrationPolicy"
  ): TypedContractMethod<[ipId: AddressLike], [string], "nonpayable">;
  getFunction(
    nameOrSignature: "whitelistArbitrationPolicy"
  ): TypedContractMethod<
    [arbitrationPolicy: AddressLike, allowed: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "whitelistDisputeTag"
  ): TypedContractMethod<
    [tag: BytesLike, allowed: boolean],
    [void],
    "nonpayable"
  >;

  getEvent(
    key: "ArbitrationPolicyCooldownUpdated"
  ): TypedContractEvent<
    ArbitrationPolicyCooldownUpdatedEvent.InputTuple,
    ArbitrationPolicyCooldownUpdatedEvent.OutputTuple,
    ArbitrationPolicyCooldownUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ArbitrationPolicySet"
  ): TypedContractEvent<
    ArbitrationPolicySetEvent.InputTuple,
    ArbitrationPolicySetEvent.OutputTuple,
    ArbitrationPolicySetEvent.OutputObject
  >;
  getEvent(
    key: "ArbitrationPolicyWhitelistUpdated"
  ): TypedContractEvent<
    ArbitrationPolicyWhitelistUpdatedEvent.InputTuple,
    ArbitrationPolicyWhitelistUpdatedEvent.OutputTuple,
    ArbitrationPolicyWhitelistUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ArbitrationRelayerUpdated"
  ): TypedContractEvent<
    ArbitrationRelayerUpdatedEvent.InputTuple,
    ArbitrationRelayerUpdatedEvent.OutputTuple,
    ArbitrationRelayerUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "DefaultArbitrationPolicyUpdated"
  ): TypedContractEvent<
    DefaultArbitrationPolicyUpdatedEvent.InputTuple,
    DefaultArbitrationPolicyUpdatedEvent.OutputTuple,
    DefaultArbitrationPolicyUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "DisputeCancelled"
  ): TypedContractEvent<
    DisputeCancelledEvent.InputTuple,
    DisputeCancelledEvent.OutputTuple,
    DisputeCancelledEvent.OutputObject
  >;
  getEvent(
    key: "DisputeJudgementSet"
  ): TypedContractEvent<
    DisputeJudgementSetEvent.InputTuple,
    DisputeJudgementSetEvent.OutputTuple,
    DisputeJudgementSetEvent.OutputObject
  >;
  getEvent(
    key: "DisputeRaised"
  ): TypedContractEvent<
    DisputeRaisedEvent.InputTuple,
    DisputeRaisedEvent.OutputTuple,
    DisputeRaisedEvent.OutputObject
  >;
  getEvent(
    key: "DisputeResolved"
  ): TypedContractEvent<
    DisputeResolvedEvent.InputTuple,
    DisputeResolvedEvent.OutputTuple,
    DisputeResolvedEvent.OutputObject
  >;
  getEvent(
    key: "IpTaggedOnRelatedIpInfringement"
  ): TypedContractEvent<
    IpTaggedOnRelatedIpInfringementEvent.InputTuple,
    IpTaggedOnRelatedIpInfringementEvent.OutputTuple,
    IpTaggedOnRelatedIpInfringementEvent.OutputObject
  >;
  getEvent(
    key: "TagWhitelistUpdated"
  ): TypedContractEvent<
    TagWhitelistUpdatedEvent.InputTuple,
    TagWhitelistUpdatedEvent.OutputTuple,
    TagWhitelistUpdatedEvent.OutputObject
  >;

  filters: {
    "ArbitrationPolicyCooldownUpdated(uint256)": TypedContractEvent<
      ArbitrationPolicyCooldownUpdatedEvent.InputTuple,
      ArbitrationPolicyCooldownUpdatedEvent.OutputTuple,
      ArbitrationPolicyCooldownUpdatedEvent.OutputObject
    >;
    ArbitrationPolicyCooldownUpdated: TypedContractEvent<
      ArbitrationPolicyCooldownUpdatedEvent.InputTuple,
      ArbitrationPolicyCooldownUpdatedEvent.OutputTuple,
      ArbitrationPolicyCooldownUpdatedEvent.OutputObject
    >;

    "ArbitrationPolicySet(address,address,uint256)": TypedContractEvent<
      ArbitrationPolicySetEvent.InputTuple,
      ArbitrationPolicySetEvent.OutputTuple,
      ArbitrationPolicySetEvent.OutputObject
    >;
    ArbitrationPolicySet: TypedContractEvent<
      ArbitrationPolicySetEvent.InputTuple,
      ArbitrationPolicySetEvent.OutputTuple,
      ArbitrationPolicySetEvent.OutputObject
    >;

    "ArbitrationPolicyWhitelistUpdated(address,bool)": TypedContractEvent<
      ArbitrationPolicyWhitelistUpdatedEvent.InputTuple,
      ArbitrationPolicyWhitelistUpdatedEvent.OutputTuple,
      ArbitrationPolicyWhitelistUpdatedEvent.OutputObject
    >;
    ArbitrationPolicyWhitelistUpdated: TypedContractEvent<
      ArbitrationPolicyWhitelistUpdatedEvent.InputTuple,
      ArbitrationPolicyWhitelistUpdatedEvent.OutputTuple,
      ArbitrationPolicyWhitelistUpdatedEvent.OutputObject
    >;

    "ArbitrationRelayerUpdated(address,address)": TypedContractEvent<
      ArbitrationRelayerUpdatedEvent.InputTuple,
      ArbitrationRelayerUpdatedEvent.OutputTuple,
      ArbitrationRelayerUpdatedEvent.OutputObject
    >;
    ArbitrationRelayerUpdated: TypedContractEvent<
      ArbitrationRelayerUpdatedEvent.InputTuple,
      ArbitrationRelayerUpdatedEvent.OutputTuple,
      ArbitrationRelayerUpdatedEvent.OutputObject
    >;

    "DefaultArbitrationPolicyUpdated(address)": TypedContractEvent<
      DefaultArbitrationPolicyUpdatedEvent.InputTuple,
      DefaultArbitrationPolicyUpdatedEvent.OutputTuple,
      DefaultArbitrationPolicyUpdatedEvent.OutputObject
    >;
    DefaultArbitrationPolicyUpdated: TypedContractEvent<
      DefaultArbitrationPolicyUpdatedEvent.InputTuple,
      DefaultArbitrationPolicyUpdatedEvent.OutputTuple,
      DefaultArbitrationPolicyUpdatedEvent.OutputObject
    >;

    "DisputeCancelled(uint256,bytes)": TypedContractEvent<
      DisputeCancelledEvent.InputTuple,
      DisputeCancelledEvent.OutputTuple,
      DisputeCancelledEvent.OutputObject
    >;
    DisputeCancelled: TypedContractEvent<
      DisputeCancelledEvent.InputTuple,
      DisputeCancelledEvent.OutputTuple,
      DisputeCancelledEvent.OutputObject
    >;

    "DisputeJudgementSet(uint256,bool,bytes)": TypedContractEvent<
      DisputeJudgementSetEvent.InputTuple,
      DisputeJudgementSetEvent.OutputTuple,
      DisputeJudgementSetEvent.OutputObject
    >;
    DisputeJudgementSet: TypedContractEvent<
      DisputeJudgementSetEvent.InputTuple,
      DisputeJudgementSetEvent.OutputTuple,
      DisputeJudgementSetEvent.OutputObject
    >;

    "DisputeRaised(uint256,address,address,address,uint256,address,bytes32,bytes32,bytes)": TypedContractEvent<
      DisputeRaisedEvent.InputTuple,
      DisputeRaisedEvent.OutputTuple,
      DisputeRaisedEvent.OutputObject
    >;
    DisputeRaised: TypedContractEvent<
      DisputeRaisedEvent.InputTuple,
      DisputeRaisedEvent.OutputTuple,
      DisputeRaisedEvent.OutputObject
    >;

    "DisputeResolved(uint256,bytes)": TypedContractEvent<
      DisputeResolvedEvent.InputTuple,
      DisputeResolvedEvent.OutputTuple,
      DisputeResolvedEvent.OutputObject
    >;
    DisputeResolved: TypedContractEvent<
      DisputeResolvedEvent.InputTuple,
      DisputeResolvedEvent.OutputTuple,
      DisputeResolvedEvent.OutputObject
    >;

    "IpTaggedOnRelatedIpInfringement(uint256,address,address,uint256,bytes32,uint256)": TypedContractEvent<
      IpTaggedOnRelatedIpInfringementEvent.InputTuple,
      IpTaggedOnRelatedIpInfringementEvent.OutputTuple,
      IpTaggedOnRelatedIpInfringementEvent.OutputObject
    >;
    IpTaggedOnRelatedIpInfringement: TypedContractEvent<
      IpTaggedOnRelatedIpInfringementEvent.InputTuple,
      IpTaggedOnRelatedIpInfringementEvent.OutputTuple,
      IpTaggedOnRelatedIpInfringementEvent.OutputObject
    >;

    "TagWhitelistUpdated(bytes32,bool)": TypedContractEvent<
      TagWhitelistUpdatedEvent.InputTuple,
      TagWhitelistUpdatedEvent.OutputTuple,
      TagWhitelistUpdatedEvent.OutputObject
    >;
    TagWhitelistUpdated: TypedContractEvent<
      TagWhitelistUpdatedEvent.InputTuple,
      TagWhitelistUpdatedEvent.OutputTuple,
      TagWhitelistUpdatedEvent.OutputObject
    >;
  };
}
